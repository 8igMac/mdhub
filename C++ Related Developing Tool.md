C++ Related Developing Tool
===
[toc]

# GPROF
Gprof is a performance analysis tool for Unix application. It is a sampling-based and instruction injection profiler. It can be used to detect a **hotspot** of a program.

## How it works
- A sampling-based profiler tool will insert a timer interrupt service routine (ISR) into your program.
- The timer will interrupt the processor at a fixed frequency, say, 100 Hz, and the ISR collect samples of the program counter (PC) during the execution of the program.
- The PC sample file (gmon.out for gprof) can be cross-referenced with the program memory map generated by the compiler to collect the time CPU spent in afunction.

## Limitation
1. **Gprof cannot measure time spent in kernel mode** (syscalls, waiting for CPU or I/O waiting), and only user-space code is profiled
2. The mcount function may not be thread-safe in some implementations, so **multi-threaded application profiles can be incorrect** (typically it only profiles the main thread of application).
3. **Instrumentation overhead**(increase in binary siz e of execution time) can be high (estimated as 30%-260%) for higher-order or object-oriented programs. 
4. **Mutual recursion and non-trivial cycles are not resolvable by the gprof approach** (context-insensitive call graph), because it only records arc traversal, not full call chains.
5. Gprof with call-graph collecting **can be used only with compatible compilers**, like GCC, clang/LLVM and some other.

## Usage
Sampling data is saved in 'gmon.out' or in 'progname.gmon' file just before the program exits, and can be analyzed with the 'gprof' command-line tool. Several gmon files can be combined with 'gprof -s' to accumulate data from several runs of a program.

1. Compile your program with `-pg` flag then execute it. After the execution, 'gmon.out' will be generated.
```
$ g++ -pg test.cpp
```
2. Use gprof to analyze the profile result.
```
$ gprof a.out gmon.out > profile.txt
```
Gprof output consists of two parts: the **flat profile** and the **call graph**. 

The **flat profile** gives the total execution time spent in each function and its percentage of the total running time. Function call counts are also reported. Output is sorted by percentage, with hot spots at the top of the list.

The second part of the output is the textual **call graph**, which shows for each function who called it (parent) and who it called (child subroutines). 

There is an external tool called [gprof2dot](https://github.com/jrfonseca/gprof2dot) capable of converting the call graph from gprof into graphical form.

3. After installing gprof2dot, execute the following command and your will see the output call grpah.
```
$ gprof path/to/your/execuable | gprof2dot | dot -Tpng -o ouput.png
```

## Reference
- [wikipedia](https://en.wikipedia.org/wiki/Gprof)
- [GUN gprof docs](https://sourceware.org/binutils/docs/gprof/index.html#Top)

# CGDB
CGDB is basically GDB that has a split window which can display the source code as it execute. In other words, it is a lightweight GDB interface.

The UI is vim key based.

## Features
- Syntax-highlighted source window
- Visual breakpoint setting
- Keyboard shortcuts for common functions
- Searching source window (using regexp) 

## Usage
cgdb have the following 2 major windows,
1. regular GDB window (press `i` to focus on this window)
2. source window (press `esc` to focus on this window)

### Geting in and out of cgdb
- type `cgdb` to start cgdb.
- type `quit` or `C-d` in the GDB window to exit.
- type `:quit` in the source window to exit. This even works if GDB is currently hanging, or operating a long command. 

### Workflow
1. Compile your program with `-g` flag.
```
$ g++ -g test.cpp
```
2. enter cgdb
```
$ cgdb
```
3. select debug fileand start debuging. 
```
$ file your/executable
```
Other useful function and hot-key please refer to **Reference**.


## Reference
- [CGDB official website](https://cgdb.github.io/)

# docker


# cmake


# doxygen
A auto documenting tool that you can write special syntax on your comment and doxygen will read it and auto generate a documentation for the code. By doing so, you don't have to do double work (add comment for the code and then write a documentation) when developing and future maintaining your software. 

Doxygen support different format of output document (most commonly html).  

## common syntax
1. `@brief`: brief description
2. `@details`: detailed description
3. `@param`: function parameter
4. `@tparam`: template parameter
5. `@return`: function return 

## Reference
[Doxygen: Main Page](http://www.stack.nl/~dimitri/doxygen/)
